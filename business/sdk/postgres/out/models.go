// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Channel string

const (
	ChannelSMS   Channel = "SMS"
	ChannelEMAIL Channel = "EMAIL"
)

func (e *Channel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Channel(s)
	case string:
		*e = Channel(s)
	default:
		return fmt.Errorf("unsupported scan type for Channel: %T", src)
	}
	return nil
}

type NullChannel struct {
	Channel Channel
	Valid   bool // Valid is true if Channel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChannel) Scan(value interface{}) error {
	if value == nil {
		ns.Channel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Channel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChannel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Channel), nil
}

type Decision string

const (
	DecisionAPPROVED Decision = "APPROVED"
	DecisionDECLINED Decision = "DECLINED"
	DecisionUNKNOWN  Decision = "UNKNOWN"
)

func (e *Decision) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Decision(s)
	case string:
		*e = Decision(s)
	default:
		return fmt.Errorf("unsupported scan type for Decision: %T", src)
	}
	return nil
}

type NullDecision struct {
	Decision Decision
	Valid    bool // Valid is true if Decision is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDecision) Scan(value interface{}) error {
	if value == nil {
		ns.Decision, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Decision.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDecision) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Decision), nil
}

type DocumentStatus string

const (
	DocumentStatusPENDING  DocumentStatus = "PENDING"
	DocumentStatusREJECTED DocumentStatus = "REJECTED"
	DocumentStatusAPPROVED DocumentStatus = "APPROVED"
	DocumentStatusDRAFT    DocumentStatus = "DRAFT"
)

func (e *DocumentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DocumentStatus(s)
	case string:
		*e = DocumentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for DocumentStatus: %T", src)
	}
	return nil
}

type NullDocumentStatus struct {
	DocumentStatus DocumentStatus
	Valid          bool // Valid is true if DocumentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDocumentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.DocumentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DocumentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDocumentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DocumentStatus), nil
}

type Entity string

const (
	EntityESTATE             Entity = "ESTATE"
	EntitySOLEPROPRIETOR     Entity = "SOLE_PROPRIETOR"
	EntityCORPORATION        Entity = "CORPORATION"
	EntityEXEMPTORGANIZATION Entity = "EXEMPT_ORGANIZATION"
)

func (e *Entity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Entity(s)
	case string:
		*e = Entity(s)
	default:
		return fmt.Errorf("unsupported scan type for Entity: %T", src)
	}
	return nil
}

type NullEntity struct {
	Entity Entity
	Valid  bool // Valid is true if Entity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntity) Scan(value interface{}) error {
	if value == nil {
		ns.Entity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Entity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Entity), nil
}

type IdentificationType string

const (
	IdentificationTypePASSPORT       IdentificationType = "PASSPORT"
	IdentificationTypeDRIVERSLICENSE IdentificationType = "DRIVERS_LICENSE"
	IdentificationTypeNATIONALID     IdentificationType = "NATIONAL_ID"
	IdentificationTypeRESIDENTPERMIT IdentificationType = "RESIDENT_PERMIT"
	IdentificationTypeSSN            IdentificationType = "SSN"
)

func (e *IdentificationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IdentificationType(s)
	case string:
		*e = IdentificationType(s)
	default:
		return fmt.Errorf("unsupported scan type for IdentificationType: %T", src)
	}
	return nil
}

type NullIdentificationType struct {
	IdentificationType IdentificationType
	Valid              bool // Valid is true if IdentificationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIdentificationType) Scan(value interface{}) error {
	if value == nil {
		ns.IdentificationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IdentificationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIdentificationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IdentificationType), nil
}

type Outcome string

const (
	OutcomeCLEARED         Outcome = "CLEARED"
	OutcomeATTENTIONNEEDED Outcome = "ATTENTION_NEEDED"
)

func (e *Outcome) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Outcome(s)
	case string:
		*e = Outcome(s)
	default:
		return fmt.Errorf("unsupported scan type for Outcome: %T", src)
	}
	return nil
}

type NullOutcome struct {
	Outcome Outcome
	Valid   bool // Valid is true if Outcome is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOutcome) Scan(value interface{}) error {
	if value == nil {
		ns.Outcome, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Outcome.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOutcome) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Outcome), nil
}

type Status string

const (
	StatusAPPROVED Status = "APPROVED"
	StatusPENDING  Status = "PENDING"
	StatusREJECTED Status = "REJECTED"
	StatusDRAFT    Status = "DRAFT"
)

func (e *Status) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Status(s)
	case string:
		*e = Status(s)
	default:
		return fmt.Errorf("unsupported scan type for Status: %T", src)
	}
	return nil
}

type NullStatus struct {
	Status Status
	Valid  bool // Valid is true if Status is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Status, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Status.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Status), nil
}

type Businesses struct {
	ID                 uuid.UUID
	OrgID              uuid.NullUUID
	LegalName          string
	Entity             Entity
	TaxID              pgtype.Text
	Dba                string
	Jurisdiction       string
	AdminID            uuid.UUID
	Owners             []byte
	Address            []byte
	Website            pgtype.Text
	PhoneNumbers       []byte
	EmailAddresses     []byte
	Documents          []byte
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	RegistrationNumber pgtype.Text
}

type Customers struct {
	ID              uuid.UUID
	FirstName       string
	LastName        string
	MiddleName      pgtype.Text
	OrgID           uuid.NullUUID
	CreatorID       uuid.NullUUID
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	CityOfBirth     pgtype.Text
	BirthCountry    pgtype.Text
	DateOfBirth     pgtype.Date
	Identifications []byte
	Addresses       []byte
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	DeletedAt       pgtype.Timestamp
}

type Documents struct {
	ID           uuid.UUID
	CustomerID   uuid.NullUUID
	BusinessID   uuid.NullUUID
	OriginalName pgtype.Text
	Filename     pgtype.Text
	Mimetype     pgtype.Text
	CreatedAt    pgtype.Timestamp
	Status       NullDocumentStatus
	CreatorID    uuid.NullUUID
	Metadata     []byte
	UpdatedAt    pgtype.Timestamp
}

type Identifications struct {
	ID                 uuid.UUID
	FirstName          pgtype.Text
	LastName           pgtype.Text
	MiddleName         pgtype.Text
	OtherNames         pgtype.Text
	Pin                string
	IdentificationType IdentificationType
	IssuedCountry      pgtype.Text
	IssuedDate         pgtype.Date
	PlaceOfBirth       pgtype.Text
	PlaceOfIssue       pgtype.Text
	DateOfBirth        pgtype.Date
	Address1           pgtype.Text
	Address2           pgtype.Text
	City               pgtype.Text
	StateRegion        pgtype.Text
	ZipCode            pgtype.Text
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
}

type Organizations struct {
	ID        uuid.UUID
	Name      string
	Status    NullStatus
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

type Otps struct {
	ID          uuid.NullUUID
	CustomerID  uuid.NullUUID
	HashedCode  pgtype.Text
	Code        pgtype.Text
	Channel     NullChannel
	ExpiresAt   pgtype.Timestamp
	VerifiedAt  pgtype.Timestamp
	Destination string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

type StoredEvents struct {
	ID               uuid.NullUUID
	Type             pgtype.Text
	AggregateID      uuid.NullUUID
	AggregateType    pgtype.Text
	AggregateVersion pgtype.Int8
	Data             []byte
	MetaData         []byte
	OccuredAt        pgtype.Timestamp
	RegisteredAt     pgtype.Timestamp
}

type Verifications struct {
	ID               uuid.UUID
	VerificationType pgtype.Text
	CustomerID       uuid.UUID
	Customer         []byte
	Business         []byte
	BusinessID       pgtype.Text
	OrgID            pgtype.Text
	CreatorID        uuid.UUID
	Outcome          NullOutcome
	AmlInsight       []byte
	PhoneInsight     []byte
	Decision         NullDecision
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}
